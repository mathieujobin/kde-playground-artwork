#include <QCoreApplication>
#include <QDebug>

#include <QStringList>

#include <ostream>
#include <iostream>
#include <stdlib.h>

#include "specification.h"
#include <QFile>
#include <QTextStream>

using namespace Cokoon;

#define LINE(content) hdr << content << endl;
#define ENUM_START(name) hdr << "enum " << name << " {" << endl;
#define ENUM_END hdr << "};" << endl;

int main(int argc, char **argv) {
    QCoreApplication app(argc, argv);

    QStringList args = app.arguments();

    if (args.size() == 3) {
        Cokoon::DocumentSpecification docSpec;
        QString specFileName(args.at(1));
        if (!docSpec.loadSpecification(specFileName) ) {
            return 1;
        }


        QString hdrFileName(args.at(2)); // TODO: use specName() as fileName?

        QFile hdrFile( hdrFileName );
        if ( !hdrFile.open( QIODevice::WriteOnly ) ) {
            qWarning("Can't open '%s' for writing.", qPrintable(hdrFileName) );
            return 1;
        }

        QTextStream hdr( &hdrFile );

        hdr << "// This file is generated by cokoonspecification_compiler from " << specFileName << "." << endl;
        hdr << "// All changes you do to this file will be lost." << endl << endl;
        hdr << "#ifndef " << docSpec.specName() << "_H" << endl;
        hdr << "#define " << docSpec.specName() << "_H" << endl;
        hdr << "namespace " << docSpec.specName() << " {" << endl;
        hdr << "namespace Var {" << endl;
        ENUM_START("Variables");
        int idx = 0;
        foreach(const QString &v, docSpec.variables()) {
            hdr << " " << v << "=" << idx << "," << endl;
            ++idx;
        }
        hdr << " Variables__Count" << endl;
        ENUM_END;
        hdr << "} // namespace Var" << endl;

        ENUM_START("Identifiers");
        idx = 0;
        foreach(const QString &i, docSpec.enumIdentifiers()) {
            hdr << " " << i << "=" << idx << "," << endl;
            idx++;
        }
        hdr << " Identifiers__Count" << endl;
        ENUM_END;
        ENUM_START("Items");
        idx = 0;
        foreach(SpecificationItem *i, docSpec.items()) {
            hdr << " " << i->id << " = " << idx << "," << endl;
            ++idx;
        }
        hdr << " Items__Count" << endl;
        ENUM_END;

        idx = 0;
        foreach(SpecificationItem *i, docSpec.items()) {
            int stateLevelIdx = 0;
            foreach (SpecificationItemStateLevel *lvl, i->stateLevels) {
                ENUM_START(i->id << "States" << stateLevelIdx);
                int stateIdx = 0;
                foreach(const QString &s, lvl->states) {
                    hdr << " " << i->id << stateLevelIdx << "_" << s << "=" << docSpec.mapItemStateToId(idx,stateLevelIdx,s) << ((stateIdx<lvl->states.count()-1)?",":"") << endl;
                    stateIdx++;
                }
                ENUM_END;
                stateLevelIdx++;
            }
            ++idx;
        }

        hdr << "class SpecDocument : public Cokoon::Document {" << endl;
        hdr << "public:" << endl;
        hdr << "int mapToId(Cokoon::Document::DeclarationType type,const QString &str) const {" << endl;
        hdr << " switch(type) {" << endl;
        hdr << " case Cokoon::Document::ObjectStateDecl:" << endl;
        hdr << "  if (false) { return -1; }" << endl;
        foreach(const SpecificationItem *i, docSpec.items()) {
            hdr << "  else if(str==\"" << i->id << "\") { return " << i->id << "; }" << endl;
        }
        hdr << "  break;" << endl;
        hdr << " case Cokoon::Document::VariableDecl:" << endl;
        hdr << "  if (false) { return -1; }" << endl;
        foreach(const QString &s, docSpec.variables()) {
            hdr << "  else if(str==\"" << s << "\") { return Var::" << s << "; }" << endl;
        }
        hdr << "  break;" << endl;
        hdr << " case Cokoon::Document::IdentifierDecl:" << endl;
        hdr << "  if (false) { return -1; }" << endl;
        int cnt = 0;
        foreach(const QString &s, docSpec.enumIdentifiers()) {
            hdr << "  else if(str==\"" << docSpec.identifiers()[cnt] << "\") { return " << s << "; }" << endl;
            cnt++;
        }
        hdr << "  break;" << endl;
        hdr << " case Cokoon::Document::ObjectNameDecl: break;" << endl;
        hdr << " }" << endl;
        hdr << " return Cokoon::Document::mapToId(type,str);" << endl;
        hdr << "}" << endl;

        hdr << "int customIdMappingBase(Cokoon::Document::DeclarationType type) const {" << endl;
        hdr << " switch(type) {" << endl;
        hdr << " case Cokoon::Document::ObjectStateDecl: return Items__Count;" << endl;
        hdr << " case Cokoon::Document::VariableDecl:   return Var::Variables__Count;" << endl;
        hdr << " case Cokoon::Document::IdentifierDecl: return Identifiers__Count;" << endl;
        hdr << " case Cokoon::Document::ObjectNameDecl: break;" << endl;
        hdr << " }" << endl;
        hdr << "return Cokoon::Document::customIdMappingBase(type);" << endl;
        LINE("}");

        LINE("int objectStateLevels(int objId) const {");
        LINE(" switch(objId) {");
        foreach(const SpecificationItem *i, docSpec.items()) {
            LINE(" case " << i->id << ": return " << i->stateLevels.size() << ";");
        }
        LINE(" default: return -1;");
        LINE(" }");
        LINE("}");

        LINE("int objectStateLevelStates(int itemId, int stateLevel) const {");
        LINE("  switch(itemId) {");
        foreach(const SpecificationItem *i, docSpec.items()) {
            LINE("  case " << i->id << ":");
            LINE("    switch(stateLevel) {");
            int cnt = 0;
            foreach(const SpecificationItemStateLevel *lvl, i->stateLevels) {
                LINE("    case " << cnt << ": return " << lvl->states.size() << ";" );
                cnt++;
            }
            LINE("    default: return -1;");
            LINE("    }");
        }
        LINE("  default: return -1;");
        LINE("  }");
        LINE("}");

        LINE("int mapObjectStateToId(int itemId, int stateLevel, const QString &stateName) const {");
        LINE(" switch(itemId) {");
        foreach(const SpecificationItem *i, docSpec.items()) {
            LINE(" case " << i->id << ":");
            LINE("  switch(stateLevel) {");
            int cnt = 0;
            foreach(const SpecificationItemStateLevel *lvl, i->stateLevels) {
                LINE("   case " << cnt << ":" );
                LINE("    if (false) {;}");
                foreach(const QString &s, lvl->states) {
                    LINE("    else if (stateName==\"" << s << "\") return " << i->id << cnt << "_" << s << ";");
                }
                LINE("    return -1;");
                cnt++;
            }
            LINE("  default: return -1;");
            LINE("  }");
        }
        LINE(" default: return -1;");

        LINE(" }");
        LINE("}");


        LINE("int mapObjectStateToId(int itemId, int stateLevel, int stateNumber) const {");
        LINE(" switch(itemId) {");
        foreach(const SpecificationItem *i, docSpec.items()) {
            LINE(" case " << i->id << ":");
            LINE("  switch(stateLevel) {");
            int cnt = 0;
            foreach(const SpecificationItemStateLevel *lvl, i->stateLevels) {
                LINE("   case " << cnt << ":" );
                LINE("    switch(stateNumber) {");
                int cnt2 = 0;
                foreach(const QString &s, lvl->states) {
                    LINE("     case " << cnt2 << ": return " << i->id << cnt << "_" << s << ";");
                    cnt2++;
                }
                LINE("    default: return -1;");
                LINE("    }");
                cnt++;
            }
            LINE("    break;");
            LINE("  default: return -1;");
            LINE("  }");
        }
        LINE(" default: return -1;");

        LINE(" }");
        LINE("}");

        hdr << "}; // end class" << endl;
        hdr << "} // namespace" << endl;
        hdr << "#endif // " << docSpec.specName() << "_H" << endl;


    } else {
        qWarning("usage: %s xmlSource cppHeaderDestination", qPrintable(args.at(0)) );
    }

}
